#script "Models of Photoshopr"
//Simple mix for getting/setting options
GetSetOptions = {
    get: function(name){
        return this.options && this.options[name];
    }, 
    set: function(name, value){
        this.options && (this.options[name] = value);
    }
}

//Gradient model
var Gradient = function(o){
    return this._init(o);
}    
Gradient.prototype =extend({}, {
    options: {
        type: "linear", //radial, linear, reflected
        steps: [], //{location, color}
        angle: 0, //in deg
        opacity: 100, //resilting opacity of gradient, applied after color opacities
        LOCATION_RANGE:100,
        comment: "", //To insert in css rendering
        mode: "normal" //mode to mix gradient in
    },
    _init: function(o){
        var self = this;
        self.options = extend({},self.options, o);
        return self;
    },
    applyOverlay: function(color, mode){
    },
    toCSS: function(prefix){
        var self = this, o = self.options,
        result = "";
        prefix = prefix || "";
        //Make type of gradient
        switch (o.type) {
            case "radial":
                result+= prefix + "radial-gradient(";
                break;
            default:
                result+= prefix + "linear-gradient(";
                //Do direction
                switch (o.angle){
                    case 90:
                        result += "top, ";
                        break;
                    case -90:
                    case 270:
                    result += "bottom, ";
                    break;
                    case 0:
                    result += "right, ";
                    break;
                    case 180:
                    case -180:
                    result += "left, ";
                    break;
                    default:
                    result += angle + "deg, ";
                }
            }
        //Make steps of gradient
        o.steps.sort(function(a,b){return a.location - b.location});
        for (var i = 0; i < o.steps; i++){
            result += o.steps[i].color.applyOpacity(o.opacity).toCSS();
            result += o.steps[i].location + "%, ";
        }
    result = result.substr (0, result.length-2) + ')';
    o.comment && (result += " /*" + o.comment + "*/");
    return result;
    }
}, GetSetOptions);



//Extend color model
var Color = function(arg){
    return this._init(arg);
}
extend(Color, {
    //Create new color object
    create : function(arg, opts) {
        if (arg instanceof SolidColor) {//clone color
            var c = new Color(extend({
                color:arg
            }, opts));
            return c;
        }
        else if (arg instanceof ActionDescriptor) {//create from actiondescr
            var sc = new SolidColor();
            sc.rgb.red=Math.round(arg.getDouble(s2t("red")));
            sc.rgb.green=Math.round(arg.getDouble(s2t("grain")));
            sc.rgb.blue=Math.round(arg.getDouble(s2t("blue")));
            var c = new Color(extend({
                color:sc
            },opts));
            return c;
        } else { //simple create
            return new Color(arg);
        }
    }
});
extend(Color.prototype, {
    options:{
        mode:'normal',
        format: 'rgb', //hsl, rgb, hex
        opacity: 100,
        color:null, //It would be a SolidColor
        comment:"" //To insert after color def in css
    },
    _init:function(opts){
        var self = this, o = self.options;
        self.options = extend({},self.options, opts);
        if (!o.color) o.color = new SolidColor();
        return self;
    },
    r:function(arg){return (arg!==undefined) ? (this.options.color.rgb.red = arg) : this.options.color.rgb.red},
    g:function(arg){return (arg!==undefined) ? (this.options.color.rgb.green= arg) : this.options.color.rgb.green},
    b:function(arg){return (arg!==undefined) ? (this.options.color.rgb.blue = arg) : this.options.color.rgb.blue},
    h:function(arg){return (arg!==undefined) ? (this.options.color.hsb.hue = arg) : this.options.color.hsb.hue},
    s:function(arg){return (arg!==undefined) ? (this.options.color.hsb.saturation = arg) : this.options.color.hsb.saturation},
    br:function(arg){return (arg!==undefined) ? (this.options.color.hsb.brightness = arg) : this.options.color.hsb.brightness},
    a:function(arg){return (arg!==undefined) ? (this.options.opacity = arg*100) : this.options.opacity*.01},
    opacity:function(arg){return (arg!==undefined) ? (this.options.opacity = arg) : this.options.opacity},
    toCSS:function(){
        var self = this, o = self.options;
        var colorVal = "",
        opacity = o.opacity === 0 ? 0 : (o.opacity || 100),
        colorObj = o.color;        
        opacity = Math.round(opacity);        
        switch (o.format){
            case 'rgb':
                var r = colorObj.rgb.red.toFixed(0),
                g = colorObj.rgb.green.toFixed(0),
                b = colorObj.rgb.blue.toFixed(0);
                colorVal = (opacity >= 100) ? ('rgb('+r+', '+g+', '+b+')') : ('rgba('+r+', '+g+', '+b+', '+(opacity*.01).toFixed(2).slice(1)+')');
                break;
            case 'hsl':
                var h = colorObj.hsb.hue, 
                l = (2-colorObj.hsb.saturation*0.01) * colorObj.hsb.brightness*0.01, 
                s = colorObj.hsb.saturation*0.01 * colorObj.hsb.brightness*0.01;
                s = (l <= 1) ? l : (2 - l);
                l /= 2;
                s = s.toFixed(3)*100+'%';
                l = l.toFixed(3)*100+'%';
                colorVal = (opacity == 100) ? ('hsl('+h+', '+s+', '+l+')') : ('hsla('+h+', '+s+', '+l+', '+(opacity*.01).toFixed(2).slice(1)+')');
                break;
            case 'hex':
                colorVal = '#'+colorObj.rgb.hexValue.toLowerCase();
                break;
        }        
        o.comment && (colorVal += " /*" + o.comment + "*/");
        return colorVal;    
    },    
    //Returns new color object with color between self & colorB
    getMix : function(colorB, midpoint){
        var self = this, colorA = self.options.color,
        colorObj = new SolidColor();
        midpoint = midpoint || .5;
        midpoint = Graph.max(Graph.min(midpoint, 1), 0);
        colorObj.rgb.red = Graph.mid( colorA.rgb.red, colorB.rgb.red, midpoint );
        colorObj.rgb.green = Graph.mid( colorA.rgb.green, colorB.rgb.green, midpoint );
        colorObj.rgb.blue = Graph.mid( colorA.rgb.blue, colorB.rgb.blue, midpoint );
        return colorObj;
    },
    //Makes color opacity
    applyOpacity: function(opacity){
        var self = this, o = self.options;
        o.opacity = .01*o.opacity*opacity;
        return self;
    }
}, GetSetOptions);


//Shadow model
var Shadow = function(o){
    return this._init(o);
}
extend(Shadow.prototype,{
    options:{
        isTextShadow:false,
        inset:false,
        x:0,
        y:0,
        stroke:0,
        blur:0,
        color:null,
        opacity: 100,
        comment: ""
    },
    _init: function(o){
        var self = this;
        self.options = extend({},self.options, o);
        return self;
    },
    toCSS: function(){
        var self = this, o =this.options;
        var result = "";
        result += (o.inset?"inset ":"") + o.x+"px " + o.y + "px " + Math.round(o.blur) + "px " + (!o.isTextShadow&&o.stroke?(o.stroke+"px "):"") + o.color.toCSS();
        o.comment && (result += " /*" + o.comment + "*/");
        return result;
    },
    //Photoshop helper that sets blur & stroke from blur & spread
    blurSpread: function(blur, spread){
        var self = this, o = self.options;
        var stroke = Math.round(spread*0.01*blur);
        if (o.isTextShadow){
            extend(o,{stroke:stroke, blur:blur + stroke});
        } else {
            extend(o,{stroke:stroke, blur:blur - stroke});
        }
        return self;
    },

    //Convert dist & angle to x & y, set them to the model
    angleDistance: function(angle, distance){
        var self = this, o = self.options;
        o.x = Math.round(distance * -Math.cos(angle/180*Math.PI));
        o.y = Math.round(distance * Math.sin(angle/180*Math.PI));
    }
    
}, GetSetOptions)


//Singletone object of some graphics methods
var Graph = extend({
//Function that returns result of blending of objA and objB. Object B is ontop of objA.
applyOverlay : function(objA, objB){
    var a = "C", b = "C";    
    if (objA instanceof Gradient) a = "G";
    if (objB instanceof Gradient) b = "G";
    var result = this["apply"+a+b+"Overlay"](objA, objB, objB.get('mode'));
    return result;
},
//color over color
applyCCOverlay : function(colorA, colorB, mode){
    //Reslt of overlay is a mix of blended top layer and bottom origin layer leveraged by opacity-midpoint.
    return this.proccessBlend[mode](colorA, colorB);
},
//gradient over color
applyGCOverlay : function(grad, color, mode){
    return grad;
},
//color over gradient
applyCGOverlay : function(color, grad, mode){
    return color;
},
//gradient over gradient
applyGGOverlay : function(gradA, gradB, mode){
    return gradA
},

//Object with blend modes proccessings
proccessBlend : {
    "normal" : function(ca, cb){
        var c = new Color();
        //$.writeln(ca.toCSS());
        //$.writeln(cb.toCSS());
        c.a(ca.a() + cb.a()*(1-ca.a()));
        c.r( (cb.r() * cb.a() + ca.r() * (1 - cb.a()) * ca.a()) / c.a() );
        c.g( (cb.g() * cb.a() + ca.g() * (1 - cb.a()) * ca.a()) / c.a() );
        c.b( (cb.b() * cb.a() + ca.b() * (1 - cb.a()) * ca.a()) / c.a() );
        return c;
    },
    "darken" : function(){
    },
    "multiply" : function(){
    },    
    "colorBurn" : function(){
    },
    "linearBurn" : function(){
    },
    "darkerColor" : function(){
    },

    "lighten" : function(){
    },
    "screen" : function(){
    },
    "colorDodge" : function(){
    },
    "linearDodge" : function(){
    },
    "lighterColor" : function(){
    },

    "overlay" : function(){
    },
    "softLight" : function(){
    },
    "hardLight" : function(){
    },
    "vividLight" : function(){
    },
    "linearLight" : function(){
    },
    "pinLight" : function(){
    },
    "hardMix" : function(){
    },

    "difference" : function(){
    },
    "exclusion" : function(){
    },
    "subtract" : function(){
    },
    "divide" : function(){
    },

    "hue" : function(){
    },
    "saturation" : function(){
    },
    "color" : function(){
    },
    "luminosity" : function(){
    }
},
    
//Return color between A & B
getMidColor : function (colorA, colorB, midpoint) {
     var self = this,
    colorObj = new SolidColor();
    midpoint = midpoint || .5;
    midpoint = self.max(self.min(midpoint, 1), 0);
    colorObj.rgb.red = self.mid( colorA.rgb.red, colorB.rgb.red, midpoint );
    colorObj.rgb.green = self.mid( colorA.rgb.green, colorB.rgb.green, midpoint );
    colorObj.rgb.blue = self.mid( colorA.rgb.blue, colorB.rgb.blue, midpoint );
    return colorObj;
},
//Return value between a & b based on leverage.
mid : function(a,b,leverage){
   return a*leverage + b*(1-leverage);
}

//another f

})



