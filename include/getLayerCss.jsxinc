#script "Get Layer FX as CSS"

//Layer fx function
(function(P){
P.extend({
    prefixes : ['-webkit-','-moz-','-ms-','-o-'],
    cssModel : {
        'box-shadow':[], 
        'text-shadow':[],
        'color':[],
        'background':[],
        'width':null,
        'height':null,
        'border-radius':null,
        'text-decoration':null,
        'letter-spacing':null,
        'font-family':[],
        'font-size':null,
        'line-height':1,
        'font-weight':null,
        'font-style':null,
        'font-variant':null,
        'text-transform':null,
        'text-align':'left',
        'text-indent':null,
        'padding':null
    },

    
    //Makes model based on FX
    parseFx : function(){
        for (var i = layerFX.count; i--;){
                var key = layerFX.getKey(i), fxprop;            
                try {
                    var fxprop = layerFX.getObjectValue(key);
                    //$.writeln(t2s(key));
                    proccessFx[t2s(key)] ? proccessFx[t2s(key)](fxprop) : "";            
                } catch (err) {
                    //$.writeln("I can't get layer fx. I'm sorry.");
                }       
        }
    },


    //Fill model of text properties
    parseText : function(){
    },


    //Fill model of fill-layer properties
    parseLayer : function(){
    },


    //Object with processing funcs of different layer properties. Every function gets p.cssModel filled.
    proccessFx : {
        "dropShadow" : function(fxProp){
            var shadow,
            enabled = fxProp.getBoolean(s2t("enabled")), 
            color = fxProp.getObjectValue(s2t("color")), 
            opacity = fxProp.getUnitDoubleValue(s2t("opacity")), 
            useGlobalAngle = fxProp.getBoolean(s2t("useGlobalAngle")), 
            angle = fxProp.getUnitDoubleValue(s2t("localLightingAngle")),
            distance = fxProp.getUnitDoubleValue(s2t("distance")), 
            spread = fxProp.getUnitDoubleValue(s2t("chokeMatte")), 
            blur = fxProp.getUnitDoubleValue(s2t("blur"));        
            if (!enabled) return;
            var mode = fxProp.getEnumerationValue(s2t("mode"));
            //get global light angle
            if (useGlobalAngle) {
                var ref = new ActionReference();
                ref.putEnumerated( c2t("Lyr "), c2t("Ordn"), c2t("Trgt") ); 
                angle = executeActionGet(ref).getInteger(s2t('globalAngle'));
            }        
            var blurStroke = getBlurStroke(blur, spread);
            if (lKind == LayerKind.TEXT){
                shadow = new Shadow({
                isTextShadow: true,
                x: getX(angle, distance),
                y: getY(angle, distance),
                blur: blurStroke.blur + blurStroke.stroke,
                mode: mode,
                opacity: opacuty
                });
                cssModel['text-shadow'].push(shadow);
            } else {
                shadow = new Shadow({
                isTextShadow: false,
                x: getX(angle, distance),
                y: getY(angle, distance),
                blur: blurStroke.blur,
                stroke: blurStroke.stroke,
                mode: mode,
                opacity: opacuty
                });
                cssModel['box-shadow'].push(shadow);
            }
        },

        "outerGlow" : function(fxProp){//TODO: take into account all glowing options
            var enabled = fxProp.getBoolean(s2t("enabled")), 
            color = fxProp.getObjectValue(s2t("color")), 
            opacity = fxProp.getUnitDoubleValue(s2t("opacity")), 
            spread = fxProp.getUnitDoubleValue(s2t("chokeMatte")), 
            blur = fxProp.getUnitDoubleValue(s2t("blur"));
            if (!enabled) return; 
            var mode = fxProp.getEnumerationValue(s2t("mode"));
            var blurStroke = getBlurStroke(blur, spread);
            if (lKind == LayerKind.TEXT){
                shadow = new Shadow({
                    isTextShadow: true,
                    x: getX(angle, distance),
                    y: getY(angle, distance),
                    blur: blurStroke.blur + blurStroke.stroke,
                    mode: mode,
                    opacity: opacuty
                });
                cssModel['text-shadow'].push(shadow);
            } else {
                shadow = new Shadow({
                    isTextShadow: false,
                    x: 0,
                    y: 0,
                    blur: blurStroke.blur,
                    stroke: blurStroke.stroke,
                    mode: mode,
                    opacity: opacuty
                });
                cssModel['box-shadow'].push(shadow);
            }
        },

        "innerShadow" : function(fxProp){
            var enabled = fxProp.getBoolean(s2t("enabled")),
            color = fxProp.getObjectValue(s2t("color")), 
            opacity = fxProp.getUnitDoubleValue(s2t("opacity")), 
            spread = fxProp.getUnitDoubleValue(s2t("chokeMatte")), 
            blur = fxProp.getUnitDoubleValue(s2t("blur")),
            useGlobalAngle = fxProp.getBoolean(s2t("useGlobalAngle")), 
            angle = fxProp.getUnitDoubleValue(s2t("localLightingAngle")),
            distance = fxProp.getUnitDoubleValue(s2t("distance"));        
            if (!enabled) return;    
            var mode = fxProp.getEnumerationValue(s2t("mode"));
            if (lKind != LayerKind.TEXT) return; //TODO: maybe somewhen make text inner shadow
            //get global light angle
            if (useGlobalAngle) {
                var ref = new ActionReference();
                ref.putEnumerated( c2t("Lyr "), c2t("Ordn"), c2t("Trgt") ); 
                angle = executeActionGet(ref).getInteger(s2t('globalAngle'));
            }
            var blurStroke = getBlurStroke(blur, spread);
            if (lKind != LayerKind.TEXT){
                shadow = new Shadow({
                    isTextShadow: false,
                    inset: true,
                    x: getX(angle, distance),
                    y: getY(angle, distance),
                    blur: blurStroke.blur,
                    stroke: blurStroke.stroke,
                    mode: mode,
                    opacity: opacuty
                });
                cssModel['box-shadow'].push(shadow);
            } else {
            };
        },

        "innerGlow" : function(fxProp){//TODO: take into account all glowing options
            var styleValue = "", //resulting style
            enabled = fxProp.getBoolean(s2t("enabled")), 
            mode, //TODO: take into account
            color = fxProp.getObjectValue(s2t("color")), 
            opacity = fxProp.getUnitDoubleValue(s2t("opacity")), 
            spread = fxProp.getUnitDoubleValue(s2t("chokeMatte")), 
            blur = fxProp.getUnitDoubleValue(s2t("blur"));
            if (!enabled) return;      
            var mode = fxProp.getEnumerationValue(s2t("mode"));
            var blurStroke = getBlurStroke(blur, spread);
            if (lKind != LayerKind.TEXT){
                shadow = new Shadow({
                    isTextShadow: false,
                    inset: true,
                    x: 0,
                    y: 0,
                    blur: blurStroke.blur,
                    stroke: blurStroke.stroke,
                    mode: mode,
                    opacity: opacuty
                });
                cssModel['box-shadow'].push(shadow);
            } else {
            }
            return styleValue;
        },
        
        //Stroke
        "frameFX": function(fxProp){
            //TODO: make border colouring of gradient
            try {
            var enabled = fxProp.getBoolean(s2t("enabled")), 
            color = fxProp.getObjectValue(s2t("color")), 
            opacity = fxProp.getUnitDoubleValue(s2t("opacity")), 
            size = fxProp.getUnitDoubleValue(s2t("size")),
            position = fxProp.getEnumerationValue(s2t("style"));
            if (!enabled) return;   
            var mode = fxProp.getEnumerationValue(s2t("mode"));
            switch (settings.strokeType){
                case "box-shadow":                
                    var preObj = {x:0, y:0};
                    if (lKind == LayerKind.TEXT) preObj.isTextShadow = true;
                    else preObj.isTextShadow = false;            
                    preObj.color = getColor(color, opacity);
                    switch (t2s(position)){
                        case "outsetFrame":
                            if (preObj.isTextShadow) { preObj.blur = size } else { preObj.stroke = size };                        
                            break;
                        case "insetFrame":
                            if (preObj.isTextShadow) { preObj.blur = size } else { preObj.stroke = size; preObj.inset = false }; 
                            styleValue += "inset 0 0 0 " + size + "px " + getColor(color, opacity);
                            break;
                        case "centeredFrame":
                            if (preObj.isTextShadow) { preObj.blur = size } 
                            else { 
                                preObj.stroke = size;
                            }; 
                            styleValue += "inset 0 0 0 " + (size*.5) + "px " + getColor(color, opacity) + 
                            ", 0 0 0 " + (size*.5) + "px " + getColor(color, opacity);
                            break;
                    }
                    cssModel['box-shadow'].push(new Shadow(preObj));
                    break;
                case "outline":
                    styleValue += size + "px solid " + getColor(color, opacity);
                    cssModel['border'].push(new Border({ }) );
                    break;
                default:
                    styleValue += size + "px solid " + getColor(color, opacity);
                    cssModel['outline'].push(new Border({ }) );
                    break;
                } 
            } catch (err) {
                $.writeln(err)
            }
        },


    //Color overlay
        "solidFill": function(fxProp){
            var styleValue = "",
            enabled = fxProp.getBoolean(s2t('enabled')),
            opacity = fxProp.getUnitDoubleValue(s2t('opacity')),
            mode = fxProp.getEnumerationValue(s2t("mode")),
            color = fxProp.getObjectValue(s2t("color"));
            if (!enabled) return;
            if (t2s(mode) != "normal") {
                if (settings.showConfirms && !confirm("Color Overlay is in "+t2s(mode)+" mode. Now supported only normal mode. Copy as normal?")) return "";            
            }
            styleValue = getColorStr(color, opacity);
            css['color-overlay'] = styleValue;
            cssModel['background'].push()
            $.writeln(t2s(mode))
            return styleValue;
        },

    //Gradient overlay of layer
        "gradientFill": function(fxProp){
            var styleValue = "",
            gradient = fxProp.getObjectValue(s2t('gradient')),
            enabled = fxProp.getBoolean(s2t('enabled')),
            opacity = fxProp.getUnitDoubleValue(s2t('opacity')),
            reverse = fxProp.getBoolean(s2t('reverse')),
            angle = fxProp.getUnitDoubleValue(s2t('angle')),
            type = t2s(fxProp.getEnumerationValue(s2t("type"))),
            align = fxProp.getBoolean(s2t('align')),
            scale = fxProp.getUnitDoubleValue(s2t('scale')),
            offset = fxProp.getObjectValue(s2t('offset'));
            if(!enabled) return;    
            var mode = fxProp.getEnumerationValue(s2t("mode"));
            if (t2s(mode) != "normal") {
                if (settings.showConfirms && !confirm("Gradient Overlay is in "+t2s(mode)+" mode. Now supported only normal mode. Copy as normal?")) return "";            
            }
            
            //showObject (gradient)
            gradientForm = gradient.getEnumerationValue(s2t('gradientForm'));
            if (t2s(gradientForm) == "colorNoise") return; //dont fuck with colorNoise gradients
            
            transparency = gradient.getList(s2t('transparency')),
            colors = gradient.getList(s2t('colors')),
            iicon = gradient.getDouble(s2t('interfaceIconFrameDimmed')); //TODO: whattafuck is this? Do get know    
            
            //defining exact size of gradient and render
            var position = "";//TODO: take into account        
            switch(type){
                case "linear":
                    //do reverse
                    angle = reverse ? angle : ((angle + 180)%360);
                    styleValue += getLinearGradient(transparency, colors, angle, opacity);
                    break;
                case "radial":
                    styleValue += getRadialGradient(transparency, colors, angle, opacity);
                    break;
                case "angle":
                    //Get out
                    break;
                case "reflected":
                    //do 2 linears
                    //styleValue += 
                    break;
                case "diamond":
                    //Omg gtfo
                    break;
            }    
            css['gradient-overlay'] = styleValue;
            return styleValue;
        }


    //Fill layer

    },

    //Return linear gradient stringified
    getLinearGradient : function(transpList, colorList,angle, globalOpacity){
        globalOpacity = globalOpacity || 100; //it's overlay opacity
        var result = "linear-gradient(";
        //do color
        switch (angle){
            case 90:
                result += "top, ";
                break;
            case -90:
            case 270:
            result += "bottom, ";
            break;
            case 0:
            result += "right, ";
            break;
            case 180:
            case -180:
            result += "left, ";
            break;
            default:
            result += angle + "deg, ";
        }
        var colors = [], trans = [];
        //grab all transparents
        for (var i = transpList.count; i--;){ 
            var transpObj = transpList.getObjectValue(i),
            midpoint = transpObj.getInteger(s2t('midpoint')),//0..100, first midpoint  is always 50 
            location = transpObj.getInteger(s2t('location')),//0..4096
            opacity = transpObj.getUnitDoubleValue(s2t('opacity'));//0..100
            trans.push({location:location, opacity:opacity});
            if (midpoint!=50){//add displacement of midpoint step, if midpoint not 50
                var prev = transpList.getObjectValue(i-1)||transpObj,
                prevLocation = prev.getInteger(s2t('location')),
                prevOpacity = prev.getUnitDoubleValue(s2t('opacity'));
                trans.push({
                    location: prevLocation + (location-prevLocation)*midpoint*.01, 
                    opacity:prevOpacity + (opacity-prevOpacity)*.5
                })
            }
        } 
        trans.sort(function(a,b){return a.location - b.location});
        //grab all colors
        for (var i = 0; i < colorList.count ;i++){ 
            var colorStep = colorList.getObjectValue(i)
            midpoint = colorStep.getInteger(s2t('midpoint')),//0..100, first midpoint  is always 50 
            location = colorStep.getInteger(s2t('location')),//0..4096
            type = t2s(colorStep.getEnumerationValue(s2t('type'))),//
            color = colorStep.getObjectValue(s2t('color'));
            colors.push({location:location, type:'raw', color:color});
            if (midpoint!=50){//add displacement of midpoint step, if midpoint not 50
                    var prev = colorList.getObjectValue(i-1),//||colorStep,
                    prevLocation = prev.getInteger(s2t('location')),
                    prevColor = prev.getObjectValue(s2t('color'));
                    colors.push({
                        location: prevLocation + (location-prevLocation)*midpoint*0.01, 
                        type:'object',
                        color:getMidColor(color, prevColor)
                    })
                }
        }
        colors.sort(function(a,b){return a.location - b.location});
        
        //Generate css gradient string
        var lRange = 4096;//location range   
        var color, transp, prevColor, prevTransp;
        var stoppr = 120;
        for (var ic = 0, it = 0; ic<colors.length || it < trans.length && stoppr--; ){
            //$.writeln(stoppr+' : '+(colors[ic] && colors[ic].location)+' : '+(trans[it]&&trans[it].location));        
            color = colors[ic] || {location:lRange, color:color.color}; //end limiter color
            prevColor = colors[ic-1] || {location:0, color:color.color}; //start limiter color
            transp = trans[it] || {location:lRange, opacity:transp.opacity}; //end limiter transp
            prevTransp = trans[it-1] || {location:0, opacity: transp.opacity}; //start limiter transp
            
            if (Math.abs(color.location - transp.location) < 42) {//colorstep==transparentstep
                var pos = Math.round(color.location/lRange*100);
                result += getColor( color.color, trans.opacity*(globalOpacity*.01) ) + " " + (pos == 0 ? "0, " : (pos + "%, "));
                //$.writeln('eq')
                it++; ic++;
            } else if (color.location < transp.location){//colorstep
                result += getColor( color.color, getMid(transp.opacity, prevTransp.opacity, (color.location - prevTransp.location)/(transp.location - prevTransp.location))  ) + " ";
                result += (color.location/lRange*100).toFixed(0)+'%, ';
                //$.writeln('c < t: res')
                ic++;
            } else if (color.location > transp.location ) {//transpstep
                result += getColor( getMidColor(color.color, prevColor.color, (transp.location - prevColor.location)/(color.location - prevColor.location)), transp.opacity ) + " ";
                result += (transp.location/lRange*100).toFixed(0)+'%, ';
                //$.writeln('c > t')
                it++;
            } else {$.writeln("Dude, something is gone wrong in gradient generation: infinite cycling.");ic++; it++}
        }
        result = result.substr (0, result.length-2) + ')';    
        //$.writeln("background: "+result);
        return result;    
    },

    //Returns css blur & stroke representation in pixels of photoshop blur & stroke 
    getBlurStroke : function(blur, spread){
        return {blur:spread*0.01*blur, stroke:blur - stroke};
    },

    //Returns css blur w/o stroke. Blur is calculated to overlap 
    getBlurOnly : function(blur, spread){
        var stroke = spread*0.01*blur;
        var cssBlur = blur + stroke*.5;
        cssBlur = cssBlur ? (cssBlur.toFixed(0) + "px ") : "0 ";
        return cssBlur;
    },

    //Returns css x in pixels 
    getX : function(angle, distance){
        return Math.round(distance * -Math.cos(angle/180*Math.PI));
    },


    //Returns y css  in pixels
    getY : function(angle, distance){
        return Math.round(distance * Math.sin(angle/180*Math.PI));
    },




    /*===========================================================Rendering===============================================*/
    //Returns string from css object
    renderCssModel : function(layer){
        var cssStr = "";    
        c = settings.comments;    
        
        //Box-shadow or text-shadow
        switch (layer.kind) {
            case LayerKind.GRADIENTFILL: //This couple has a different background-fill strategy;
            case LayerKind.SOLIDFILL:
            case LayerKind.NORMAL: //This layers renders with data-URI in background;
            case LayerKind.PATTERNFILL:
                cssStr += renderFillLayer(css);
                break;
            case LayerKind.TEXT: //Text effects rendered as a text-shadow instead of box-shadow;
                cssStr += renderTextLayer(css);
                break;
        }    
        return cssStr;
    },


    //render for the text layer
    renderTextLayer : function(css){
        //Text-shadow
        var textShadow = "";
        if (css['text-outer-glow']) textShadow += css['text-outer-glow'] + (c?' /*outer-glow*/':'') + ',' + delim;
        if (css['text-drop-shadow']) textShadow += css['text-drop-shadow'] + (c?' /*drop-shadow*/':'') + ',' + delim;
        if (textShadow) textShadow = 'text-shadow:' + delim + textShadow.substr (0, textShadow.length-2) + ';\n';
        
        //Text-color
        var fillColor = ""
        if (css['color-overlay']) fillColor += getColor(css['color-overlay'])    
        
        //Text-properties
        
        
        return textShadow;
    },


    //render fill layer = gradient, solid fill
    renderFillLayer : function(css) {
        var boxShadow = "", cssStr="";
        //Box-shadow
        if (css['box-shadow-stroke']) boxShadow += css['box-shadow-stroke'] + (c?' /*stroke*/':'') + ',' + delim;
        if (css['inner-shadow']) boxShadow += css['inner-shadow'] + (c?' /*inner-shadow*/':'') + ',' + delim;
        if (css['inner-glow']) boxShadow += css['inner-glow'] + (c?' /*inner-glow*/':'') + ',' + delim;
        if (css['outer-glow']) boxShadow += css['outer-glow'] + (c?' /*outer-glow*/':'') + ',' + delim;
        if (css['drop-shadow']) boxShadow += css['drop-shadow'] + (c?' /*drop-shadow*/':'') + ',' + delim;
        if (boxShadow) boxShadow = boxShadow.substr (0, boxShadow.length-2) + ';\n';
        /*if (settings.showPrefixes){ //Box-shadow is contemporary now, prefixes are deprecated. Don't look at them.
             for (var i = prefixes.length; i--;){
                    cssStr += prefixes[i] + 'box-shadow:' + delim + boxShadow;
                 }
             } */
        if (boxShadow) boxShadow = 'box-shadow:' + delim + boxShadow;
        cssStr += boxShadow;    
         //Border Stroke    
        if (css['border-stroke']) cssStr += 'border:' + delim+css['border-stroke'] + (c?' /*stroke*/':'') + ';\n';    
        //Background
        var gradientOverlay = "", colorOverlay = "";
        if(css['gradient-overlay']) gradientOverlay += css['gradient-overlay'] + (c?' /*gradient overlay*/':'') + ',' + delim;
        if(css['color-overlay']) colorOverlay += css['color-overlay'] + (c?' /*color overlay*/':'') + ',' + delim;  
        if (gradientOverlay || colorOverlay){
            if (settings.showPrefixes){
                 for (var i = prefixes.length; i--;){
                    var background = 'background:'+ delim + colorOverlay + prefixes[i] + gradientOverlay;
                    background = background.substr (0, background.length-2) + ';\n';
                    cssStr += background;
                 }
            } 
            var background = 'background:'+ delim + colorOverlay + gradientOverlay;
            background = background.substr (0, background.length-2) + ';\n';
            cssStr += background;
        }
        
        return cssStr;
    },

   
    //Main function - returns CSS string with rendered result
    getLayerCss : function(){
        var result = "";
        //try to get active layer properties
        try {
            var layer = app.activeDocument.activeLayer;
            var lFX = getActiveLayerProperty( c2t( 'Lefx' ) ),
            lKind = layer.kind,
            lOpacity,
            lFill,
            lMode,
            lVisible,
            lText,
            lShape;
        } catch (err) {
            //No document opened or active layer selected
            return;
        }
        
        return result;                
    }

}); //end of extend
})(photoshopr);